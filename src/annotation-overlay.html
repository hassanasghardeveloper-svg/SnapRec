<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Annotation Overlay</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      overflow: hidden;
      background: transparent;
      cursor: crosshair;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }

    .toolbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      gap: 4px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.1);
      -webkit-app-region: drag;
    }

    .tool-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: transparent;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      -webkit-app-region: no-drag;
    }

    .tool-btn:hover {
      background: rgba(255,255,255,0.1);
    }

    .tool-btn.active {
      background: #e34850;
    }

    .tool-btn svg {
      width: 20px;
      height: 20px;
      stroke: white;
      fill: none;
      stroke-width: 2;
    }

    .tool-btn.active svg {
      stroke: white;
    }

    .color-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      margin: 6px 2px;
      -webkit-app-region: no-drag;
    }

    .color-btn.active {
      border-color: white;
    }

    .separator {
      width: 1px;
      background: rgba(255,255,255,0.2);
      margin: 4px 8px;
    }

    .size-slider {
      width: 80px;
      margin: 0 8px;
      -webkit-app-region: no-drag;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="toolbar">
    <!-- Tools -->
    <button class="tool-btn active" data-tool="pen" title="Pen">
      <svg viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg>
    </button>
    <button class="tool-btn" data-tool="arrow" title="Arrow">
      <svg viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
    </button>
    <button class="tool-btn" data-tool="rect" title="Rectangle">
      <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
    </button>
    <button class="tool-btn" data-tool="circle" title="Circle">
      <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>
    </button>
    <button class="tool-btn" data-tool="highlight" title="Highlighter">
      <svg viewBox="0 0 24 24"><path d="M9 11l-6 6v3h9l3-3"/><path d="M22 12l-4.6 4.6a2 2 0 01-2.8 0l-5.2-5.2a2 2 0 010-2.8L14 4"/></svg>
    </button>
    <button class="tool-btn" data-tool="text" title="Text">
      <svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
    </button>

    <div class="separator"></div>

    <!-- Colors -->
    <button class="color-btn active" data-color="#e34850" style="background:#e34850"></button>
    <button class="color-btn" data-color="#f59e0b" style="background:#f59e0b"></button>
    <button class="color-btn" data-color="#10b981" style="background:#10b981"></button>
    <button class="color-btn" data-color="#3b82f6" style="background:#3b82f6"></button>
    <button class="color-btn" data-color="#ffffff" style="background:#ffffff"></button>

    <div class="separator"></div>

    <!-- Size -->
    <input type="range" class="size-slider" min="2" max="20" value="4" id="sizeSlider">

    <div class="separator"></div>

    <!-- Actions -->
    <button class="tool-btn" id="undoBtn" title="Undo">
      <svg viewBox="0 0 24 24"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 00-9-9 9 9 0 00-6 2.3L3 13"/></svg>
    </button>
    <button class="tool-btn" id="clearBtn" title="Clear All">
      <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
    </button>
    <button class="tool-btn" id="closeBtn" title="Close" style="background:#e34850">
      <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
    </button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const sizeSlider = document.getElementById('sizeSlider');

    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let currentTool = 'pen';
    let currentColor = '#e34850';
    let lineWidth = 4;
    let isDrawing = false;
    let startX, startY;
    let drawings = [];
    let currentPath = [];

    // Tool buttons
    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;
      });
    });

    // Color buttons
    document.querySelectorAll('.color-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentColor = btn.dataset.color;
      });
    });

    // Size slider
    sizeSlider.addEventListener('input', (e) => {
      lineWidth = parseInt(e.target.value);
    });

    // Drawing functions
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawings.forEach(drawing => {
        drawShape(drawing);
      });
    }

    function drawShape(drawing) {
      ctx.strokeStyle = drawing.color;
      ctx.fillStyle = drawing.color;
      ctx.lineWidth = drawing.width;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      switch (drawing.tool) {
        case 'pen':
          if (drawing.path.length < 2) return;
          ctx.beginPath();
          ctx.moveTo(drawing.path[0].x, drawing.path[0].y);
          for (let i = 1; i < drawing.path.length; i++) {
            ctx.lineTo(drawing.path[i].x, drawing.path[i].y);
          }
          ctx.stroke();
          break;

        case 'highlight':
          if (drawing.path.length < 2) return;
          ctx.globalAlpha = 0.3;
          ctx.lineWidth = drawing.width * 4;
          ctx.beginPath();
          ctx.moveTo(drawing.path[0].x, drawing.path[0].y);
          for (let i = 1; i < drawing.path.length; i++) {
            ctx.lineTo(drawing.path[i].x, drawing.path[i].y);
          }
          ctx.stroke();
          ctx.globalAlpha = 1;
          break;

        case 'arrow':
          const dx = drawing.endX - drawing.startX;
          const dy = drawing.endY - drawing.startY;
          const angle = Math.atan2(dy, dx);
          const headLen = 15;

          ctx.beginPath();
          ctx.moveTo(drawing.startX, drawing.startY);
          ctx.lineTo(drawing.endX, drawing.endY);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(drawing.endX, drawing.endY);
          ctx.lineTo(drawing.endX - headLen * Math.cos(angle - Math.PI/6), drawing.endY - headLen * Math.sin(angle - Math.PI/6));
          ctx.lineTo(drawing.endX - headLen * Math.cos(angle + Math.PI/6), drawing.endY - headLen * Math.sin(angle + Math.PI/6));
          ctx.closePath();
          ctx.fill();
          break;

        case 'rect':
          ctx.strokeRect(drawing.startX, drawing.startY, drawing.endX - drawing.startX, drawing.endY - drawing.startY);
          break;

        case 'circle':
          const radiusX = Math.abs(drawing.endX - drawing.startX) / 2;
          const radiusY = Math.abs(drawing.endY - drawing.startY) / 2;
          const centerX = drawing.startX + (drawing.endX - drawing.startX) / 2;
          const centerY = drawing.startY + (drawing.endY - drawing.startY) / 2;
          ctx.beginPath();
          ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
          ctx.stroke();
          break;

        case 'text':
          ctx.font = `${drawing.width * 4}px Arial`;
          ctx.fillText(drawing.text, drawing.startX, drawing.startY);
          break;
      }
    }

    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      startX = e.clientX;
      startY = e.clientY;
      currentPath = [{x: e.clientX, y: e.clientY}];

      if (currentTool === 'text') {
        const text = prompt('Enter text:');
        if (text) {
          drawings.push({
            tool: 'text',
            color: currentColor,
            width: lineWidth,
            startX: e.clientX,
            startY: e.clientY,
            text: text
          });
          redraw();
        }
        isDrawing = false;
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;

      if (currentTool === 'pen' || currentTool === 'highlight') {
        currentPath.push({x: e.clientX, y: e.clientY});
        redraw();
        drawShape({
          tool: currentTool,
          color: currentColor,
          width: lineWidth,
          path: currentPath
        });
      } else if (currentTool !== 'text') {
        redraw();
        drawShape({
          tool: currentTool,
          color: currentColor,
          width: lineWidth,
          startX: startX,
          startY: startY,
          endX: e.clientX,
          endY: e.clientY
        });
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (!isDrawing) return;
      isDrawing = false;

      if (currentTool === 'pen' || currentTool === 'highlight') {
        if (currentPath.length > 1) {
          drawings.push({
            tool: currentTool,
            color: currentColor,
            width: lineWidth,
            path: [...currentPath]
          });
        }
      } else if (currentTool !== 'text') {
        drawings.push({
          tool: currentTool,
          color: currentColor,
          width: lineWidth,
          startX: startX,
          startY: startY,
          endX: e.clientX,
          endY: e.clientY
        });
      }
      currentPath = [];
      redraw();
    });

    // Undo
    document.getElementById('undoBtn').addEventListener('click', () => {
      drawings.pop();
      redraw();
    });

    // Clear
    document.getElementById('clearBtn').addEventListener('click', () => {
      drawings = [];
      redraw();
    });

    // Close
    document.getElementById('closeBtn').addEventListener('click', () => {
      window.electronAPI.closeAnnotation();
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        window.electronAPI.closeAnnotation();
      } else if (e.ctrlKey && e.key === 'z') {
        drawings.pop();
        redraw();
      }
    });

    // Resize
    window.addEventListener('resize', () => {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.putImageData(imageData, 0, 0);
    });
  </script>
</body>
</html>
